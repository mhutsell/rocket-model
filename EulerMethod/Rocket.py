#!/usr/bin/env python3# -*- coding: utf-8 -*-"""Created on Mon Feb 17 15:58:04 2020@author: Mack"""# Rocket.pyimport mathimport numpy as npimport matplotlib.pyplot as pltimport pprintDT = 0.01                                   # set our delta t (s)gravity = -9.81                             # set gravity (m/s^2)simulation_time = 600                       # length of simulation (s)burnout_time = 60                           # period over which fuel burnsnumIterations = int(simulation_time/DT) + 1 # How many iterations we have of looprocket_mass = 1000                          # Mass of rocket without fuelinitial_mass = 5000                         # Mass of rocket with fuelfuel_mass = initial_mass-rocket_mass        # Mass of fuelmass = initial_mass                         # Variable that is tracked in loopchange_in_mass = fuel_mass/burnout_time     # How quickly our mass changes (assuming constant change)t = 0                                       # Initial timetime = [t]                                  # Initializing our time listv = 0                                       # Initial velocityvelocity = [v]                              # Initializing our velocity listp = .0001                                   # Initial positionposition = [p]                              # Initializing our position listisp = 200                                   # Initializing special impulse to 200 (from book)coefficient_drag = 0.6                    # Intializing drag coefficient to 0.6 (online)area_rocket = 10.75                         # The area of the top our rocket (from online)	# thrust_list = [0]                           # Initializing our thrust list# grav_list = [-gravity]                      # Initializing our gravity list# air_resistance_list = [0]                   # Initializing our air resistance list# mass_l = [mass]                             # Initializing mass listRADIUS_OF_EARTH = 6378100                   # This is the radius of earth                   # Function to find next iteration of valuesdef find_next_v(DT, mass, change_in_mass, v, p):        if(mass > rocket_mass):                 # This section checks to make sure        mass -= (change_in_mass) * DT       # that our rocket's mass doesn't        if(mass < rocket_mass):             # drop below the mass of its frame            mass = rocket_mass              # as that would be impossible. (lost mass is lost fuel-mass)                                            # Before it reaches the base mass                                            # of the rocket, it subtracts the                                            # change_in_mass from mass each iteration        p += (v) * DT                           # Change position based on what velocity previously was    if(p < 0):                              # Rockets can't go underground, so we check if our position is below 0        p = 0                               # if it is, we set it equal to 0        grav_a = -9.81                      # back at an altitude of 0, so grav_a = -9.81        thrust_a = 0                        # no fuel so thrust is 0        v = 0                               # can't move as can't go through earth        air_resistance_a = 0                # no air resistance if we're not moving        return(mass, change_in_mass, p, v, thrust_a, grav_a, air_resistance_a)    density_air = math.exp(-0.1385 * p/1000) # calculate the density of air at our new position    if(mass == rocket_mass):                # This if-statement makes sure that if our mass        change_in_mass = 0                  # = base rocket mass, we stop having a change in mass                                            # and therefore, thrust becomes 0, as no more fuel is used            # Calculate acceleration due to gravity    grav_a = gravity * ((RADIUS_OF_EARTH)**2)/((RADIUS_OF_EARTH+p)**2)        # Calculate acceleration due to thrust    thrust_a = (isp * grav_a * (-change_in_mass)) / mass        # Calculate acceleration due to air resistance    air_resistance_a = ((1/2) * density_air * (v) * abs(v) * coefficient_drag * area_rocket)/mass       # Calculate new velocity based on acceleration due to thrust, gravity, and air resistance    v = v + (thrust_a + grav_a - air_resistance_a) * DT        # Return our new values!    return(mass, change_in_mass, p, v, thrust_a, grav_a, air_resistance_a)# loop the desired numebr of timesfor i in range(1, numIterations):    t = i * DT                                  # Our time for each iteration     time.append(t)                              # Add to time list        # Call function and assign new values to variables    # Only call function if we are still at p != 0. Position is initalized    # to slightly above 0 so that we enter this if statement the first loop through    if(p != 0):        mass, change_in_mass, p, v, thrust_a, grav_a, air_resistance_a = find_next_v(DT, mass, change_in_mass, v, p)    # thrust_list.append(thrust_a)                # add new thrust to thrust list    # mass_l.append(mass)                         # add new mast to mass list    # grav_list.append(-grav_a)                   # add new gravity to gravity list     # air_resistance_list.append(air_resistance_a)# add new air resistance to air resistance list            velocity.append(v)                          # add new velocity to velocity list    position.append(p)                          # add new position to position list# Plot in five separate graphs:# Position vs timeplt.figure(1)plt.plot(time, position, label="Position", color="red")plt.legend(loc = 2)# Velocity vs timeplt.figure(2)plt.plot(time, velocity, label = "Velocity")plt.legend(loc = 2)# If you wanted to plot others# # Mass vs time# plt.figure(3)# plt.plot(time, mass_l, label="Mass")# plt.legend()# # Air Resistance vs time# plt.figure(4)# plt.plot(time, air_resistance_list, label = "Air Resistance")# plt.legend()# # Gravity vs time# plt.figure(5)# plt.plot(time, grav_list, label = "Gravity")# axes = plt.gca()# axes.set_ylim([0,10])# plt.legend()